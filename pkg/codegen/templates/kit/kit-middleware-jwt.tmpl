// Code generated by github.com/deepmap/oapi-codegen version (devel) DO NOT EDIT.
type Claims struct {
	// stuff we added for admins
	AdminID     int64  `json:"admin_id,string"`
	AffiliateID int64  `json:"affiliate_id,string"`
	// stuff we added for customers
	Phone  string `json:"user_phone"`
	UserID int64  `json:"user_id,string"`
	// "well known" values
	PreferredUsername string `json:"preferred_username"`
	Email string `json:"email"`
	GivenName string `json:"given_name"`
	FamilyName string `json:"family_name"`
	
	jwt.RegisteredClaims
}

type contextKey string

const ContextKeyClaims contextKey = "cambio-jwt-claims"

type JWTParser struct {
	key []byte
}

func (parser JWTParser) Keyfunc(token *jwt.Token) (interface{}, error) {

	switch token.Method {
	case jwt.SigningMethodHS256, jwt.SigningMethodHS384, jwt.SigningMethodHS512:
		return parser.key, nil
	case jwt.SigningMethodRS256:
		return rsa.GenerateKey(bytes.NewBuffer(parser.key), 256)
	case jwt.SigningMethodRS384:
		return rsa.GenerateKey(bytes.NewBuffer(parser.key), 384)
	case jwt.SigningMethodRS512:
		return rsa.GenerateKey(bytes.NewBuffer(parser.key), 512)
	}

	return nil, fmt.Errorf("cannot handle %s signed keys", token.Method)
}

type JWTMiddleware struct {
	parser JWTParser
	next http.Handler
}

func (mw JWTMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	token, err := ExtractJWT(r)
	if err != nil {
		encodeErrorResponse(r.Context(), err, w)
		return
	}

	claims, err := ParseJWT(token, mw.parser.Keyfunc)
	if err != nil {
		encodeErrorResponse(r.Context(), err, w)
		return
	}

	ctx := context.WithValue(r.Context(), ContextKeyClaims, claims)

	mw.next.ServeHTTP(w, r.WithContext(ctx))
}

func MakeJWTMiddleware(key []byte) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return JWTMiddleware{
			parser: JWTParser{ key: key },
			next: next,
		}
	}
}

func ParseJWT[T []byte|string](data T, keyFunc jwt.Keyfunc) (jwt.Claims, error) {
	token, err := jwt.ParseWithClaims(string(data), &Claims{}, keyFunc)
	if err != nil {

		if errors.Is(err, jwt.ErrTokenMalformed) {
			return nil, Error(http.StatusUnauthorized, "invalid token")
		}
		
		if errors.Is(err, jwt.ErrTokenExpired) {
			return nil, Error(http.StatusUnauthorized, "token expired")
		}
		
		return nil, err
	}
	
	if !token.Valid {
		return nil, Error(http.StatusUnauthorized, "invalid token")
	}

	if claims, ok := token.Claims.(*Claims); ok {
		return claims, nil
	}

	return nil, Error(http.StatusUnauthorized, "invalid claims")
}

var tokenExtractor = regexp.MustCompile(`^Bearer (.*)$`)

func ExtractJWT(req *http.Request) (string, error) {
	authHeader := req.Header.Get("authorization")
	if (authHeader == "")  {
		return "", Error(http.StatusUnauthorized, "missing authorization")
	}

	match := tokenExtractor.FindStringSubmatch(authHeader)
	if len(match) != 2 {
		return "", Error(http.StatusUnauthorized, "invalid authorization")
	}
	
	return match[1], nil
}


