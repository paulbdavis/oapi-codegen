// Service is the interface to be implemented for the service business
// logic
type Service interface {
{{range . -}}

// {{.OperationId}} handles {{.Method}} calls to {{.Path}}
//
{{.SummaryAsComment}}
{{.OperationId}}(ctx context.Context

{{- if .HasBody -}}

{{range $index, $body := .Bodies -}}

{{- if eq $index 0 -}}
, data {{$body.Schema.GoType}}
{{- end -}}

{{- end -}}

{{- else -}}

{{range $index, $param := .AllParams -}}
, {{- $param.ParamName}} {{if not $param.Required}}*{{end}}{{$param.Schema.GoType -}}
{{- end -}}

{{- end -}}

) {{ if not .GetResponseTypeDefinitions}} error {{else -}}
( 
{{- range $index, $return := .GetResponseTypeDefinitions -}}
{{- if $index }}, {{end -}}
*{{ $return.Schema.GoType }}
{{- end -}}
, error)
{{- end }}
{{end}}
}

type Logger interface {
	kitlog.Logger
	With(kvs ...interface{}) Logger
	Msgf(format string, args ...interface{}) error
	Msg(msg string, kvs ...interface{}) error
}

// NewJSONLogger makes a new JSON logger compatible with api.Logger using kitlog.NewSyncWriter(os.Stdout)
func NewJSONLogger(serviceName string, kvs ...interface{}) Logger {
return NewLogger(kitlog.NewJSONLogger(kitlog.NewSyncWriter(os.Stdout)), serviceName)
}

// NewLogger makes a new logger compatible with api.Logger
func NewLogger(kitlogger kitlog.Logger, serviceName string, kvs ...interface{}) Logger {
	kvs = append(kvs,
		"component", serviceName,
		"time", kitlog.DefaultTimestampUTC,
	)

	if hostname, ok := os.LookupEnv("HOSTNAME"); ok {
		kvs = append(kvs,
			"hostname", hostname)
	}

	if podname, ok := os.LookupEnv("PODNAME"); ok {
		kvs = append(kvs,
			"podname", podname)
	}

	kitlogger = kitlog.With(kitlogger, kvs...)

	return logger{kitlogger}
}

type logger struct {
	logger kitlog.Logger
}

func (lg logger) Log(kvs ...interface{}) error {
	return lg.logger.Log(kvs...)
}

func (lg logger) With(kvs ...interface{}) Logger {

	return logger{kitlog.With(lg.logger, kvs...)}
}

func (lg logger) Msgf(format string, args ...interface{}) error {
	if len(args) > 0 {
		if err, ok := args[len(args)-1].(error); ok {
			return lg.logger.Log("msg", fmt.Sprintf(format, args[:len(args)-1]...), "error", err)
		}
	}
	return lg.logger.Log("msg", fmt.Sprintf(format, args...))
}

func (lg logger) Msg(msg string, kvs ...interface{}) error {
	args := []interface{}{"msg", msg}

	lenKV := len(kvs)
	if lenKV%2 == 1 {
		if err, ok := kvs[lenKV-1].(error); ok {
			args = append(args, kvs[:lenKV-1]...)
			args = append(args, "error", err)
		} else {
			args = append(args, kvs...)
		}
	} else {
		args = append(args, kvs...)
	}

	return lg.logger.Log(args...)
}
