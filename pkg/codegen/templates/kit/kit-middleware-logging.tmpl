type LoggingMiddlewareConfig struct {
	IgnoredMethods []string
    AppendLogKVs func(context.Context) []interface{}
}

func (conf LoggingMiddlewareConfig) IsIgnoredMethod(method string) bool {
	for _, m := range conf.IgnoredMethods {
		if m == method {
			return true
		}
	}
	return false
}

// WithLoggingMiddleware wraps the provided service with logging
// middleware using the provided logger
func WithLoggingMiddleware(logger kitlog.Logger, next Service, loggingConf *LoggingMiddlewareConfig) Service {
	if loggingConf == nil {
		loggingConf = &LoggingMiddlewareConfig{IgnoredMethods: []string{"HealthCheck"}}
	}
	return loggingMiddleware{
		logger: kitlog.With(logger, "layer", "gokit"),
		next: next,
		conf: *loggingConf,
	}
}

type loggingMiddleware struct {
	logger kitlog.Logger
	next   Service
	conf LoggingMiddlewareConfig
}

{{range . -}}{{$opid := .OperationId}}

func (mw loggingMiddleware) {{$opid}}{{template "kit-function-signature" .}} {
	var err error
	defer func(begin time.Time) {
	      method := "{{$opid}}"
	      if mw.conf.IsIgnoredMethod(method) && err == nil { return; }
	      duration := time.Since(begin)
	      ms := toFixed(float64(time.Since(begin))/float64(time.Millisecond), 2)
          var coder httptransport.StatusCoder
	      kvs := []interface{}{
		      "method", method,
		      "duration", duration,
		      "ms", ms,
	      }
	      if errors.As(err, &coder) {
		     kvs = append(kvs, "code", coder.StatusCode())
	      }
	      if err != nil {
		     kvs = append(kvs, "error", err.Error())
	      }
          if mw.conf.AppendLogKVs != nil {
             kvs = append(kvs, mw.conf.AppendLogKVs(ctx)...)
          }
	      mw.logger.Log(kvs...)
    }(time.Now())

{{ if not .GetResponseTypeDefinitions }}
   err = mw.next.{{$opid}}{{template "kit-middleware-call" .}}
   return err
{{else}}
   output, err := mw.next.{{$opid}}{{template "kit-middleware-call" .}}
   return output, err
{{end}}

}
{{end}}
