type LoggingMiddlewareConfig struct {
	IgnoredMethods []string
}

func (conf LoggingMiddlewareConfig) IsIgnoredMethod(method string) bool {
	for _, m := range conf.IgnoredMethods {
		if m == method {
			return true
		}
	}
	return false
}

// WithLoggingMiddleware wraps the provided service with logging
// middleware using the provided logger
func WithLoggingMiddleware(logger kitlog.Logger, next Service, loggingConf *LoggingMiddlewareConfig) Service {
	if loggingConf == nil {
		loggingConf = &LoggingMiddlewareConfig{IgnoredMethods: []string{"HealthCheck"}}
	}
	return loggingMiddleware{
		logger: kitlog.With(logger, "layer", "gokit"),
		next: next,
		conf: *loggingConf,
	}
}

type loggingMiddleware struct {
	logger kitlog.Logger
	next   Service
	conf LoggingMiddlewareConfig
}

{{range . -}}{{$opid := .OperationId}}

func (mw loggingMiddleware) {{$opid}}{{template "kit-function-signature" .}} {
	var err error
	defer func(begin time.Time) {
	method := "{{$opid}}"
	if mw.conf.IsIgnoredMethod(method) && err == nil { return; }
	duration := time.Since(begin)
	ms := toFixed(float64(time.Since(begin))/float64(time.Millisecond), 2)
		var coder httptransport.StatusCoder
		if errors.As(err, &coder) {
		mw.logger.Log(
			"method", method,
			"error", err.Error(),
			"code", coder.StatusCode(),
			"duration", duration,
			"ms", ms,
		)
		} else {
		args := []interface{}{
			"method", method,
			"duration", duration,
			"ms", ms,
		}
		if err != nil {
		  args = append(args, "error", err.Error())
		}
		mw.logger.Log(args...)
		}
	}(time.Now())

{{ if not .GetResponseTypeDefinitions }}
   err = mw.next.{{$opid}}{{template "kit-middleware-call" .}}
   return err
{{else}}
   output, err := mw.next.{{$opid}}{{template "kit-middleware-call" .}}
   return output, err
{{end}}

}
{{end}}
