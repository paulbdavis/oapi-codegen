// WithLoggingMiddleware wraps the provided service with logging
// middleware using the provided logger
func WithLoggingMiddleware(logger kitlog.Logger, next Service) Service {
	return loggingMiddleware{kitlog.With(logger, "subsystem", "gokit"), next}
	}
    
type loggingMiddleware struct {
	logger kitlog.Logger
	next   Service
}

{{range . -}}{{$opid := .OperationId}}

func (mw loggingMiddleware) {{$opid}}(ctx context.Context

{{- if .HasBody -}}

{{range $index, $body := .Bodies -}}

{{- if eq $index 0 -}}
, data {{$body.Schema.GoType}}
{{- end -}}

{{- end -}}

{{- else -}}

{{range $index, $param := .AllParams -}}
, {{- $param.ParamName}} {{if not $param.Required}}*{{end}}{{$param.Schema.GoType -}}
{{- end -}}

{{- end -}}

) {{ if not .GetResponseTypeDefinitions}} error { {{else -}}
( 
{{- range $index, $return := .GetResponseTypeDefinitions -}}
{{- if $index }}, {{end -}}
*{{ $return.Schema.GoType }}
{{- end -}}
, error) {
{{- end }}
	var err error
	defer func(begin time.Time) {
	method := "{{$opid}}"
	if method == "HealthCheck" && err == nil { return; }
		var apiErr APIError
		if errors.As(err, &apiErr) {
		mw.logger.Log(
			"method", method,
			"error", err.Error(),
			"code", apiErr.Code,
			"took", time.Since(begin),
		)
		} else {
		args := []interface{}{
			"method", method,
			"took", time.Since(begin),
		}
		if err != nil {
		  args = append(args, "error", err.Error())
		}
		mw.logger.Log(args...)
		}
	}(time.Now())

{{ if not .GetResponseTypeDefinitions }}

{{ if .HasBody }}
	err = mw.next.{{$opid}}(ctx, data)
{{ else }}

	err = mw.next.{{$opid}}(ctx, {{range $index, $param := .AllParams -}}
{{if $index}}, {{end -}}
{{- $param.ParamName -}}
{{- end -}})

{{ end }}
	return err

{{else if .AllParams }}

	output, err := mw.next.{{$opid}}(ctx, {{range $index, $param := .AllParams -}}
{{if $index}}, {{end -}}
{{- $param.ParamName -}}
{{- end -}})

	return output, err
	
{{ else if .HasBody }}

	output, err := mw.next.{{$opid}}(ctx, data)

	return output, err
	
{{end}}

}
{{end}}
