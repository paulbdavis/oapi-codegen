// GetRouter returns a github.com/gorilla/mux router with the routes
// in the spec already set up
func GetRouter(svc Service, logger kitlog.Logger) *mux.Router {
	 r := mux.NewRouter()
	 if logger != nil {
	 	logger = kitlog.With(logger, "subsystem", "httptransport")
	 	 r.Use(makeHTTPLoggingMiddleware(logger))
	 }
{{range . -}}{{$opid := .OperationId}}
	 r.Handle("{{.Path}}", Make{{$opid}}Handler(svc)).Methods("{{.Method}}")
{{end}}
	 r.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	 if logger != nil {
		logger.Log(
			"method", r.Method,
			"path", r.URL.Path,
			"status", http.StatusNotFound,
		)
	 }
	   encodeErrorResponse(r.Context(), Error(http.StatusNotFound, "not found"), w)
	 })
	 return r
}

	type loggingResponseWriter struct {
        http.ResponseWriter
        statusCode int
    }

    func newLoggingResponseWriter(w http.ResponseWriter) *loggingResponseWriter {
        return &loggingResponseWriter{w, http.StatusOK}
    }

    func (lrw *loggingResponseWriter) WriteHeader(code int) {
        lrw.statusCode = code
        lrw.ResponseWriter.WriteHeader(code)
    }

func makeHTTPLoggingMiddleware(logger kitlog.Logger) func(http.Handler) http.Handler {
  return func(next http.Handler) http.Handler {
      return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	  lwr := newLoggingResponseWriter(w)
	defer func(begin time.Time) {
	duration := time.Since(begin)
	ms := toFixed(float64(time.Since(begin))/float64(time.Millisecond), 2)
	if r.URL.Path == "/healthz" && lwr.statusCode == http.StatusOK { return; }
		logger.Log(
			"method", r.Method,
			"path", r.URL.Path,
			"status", lwr.statusCode,
			"duration", duration,
			"ms", ms,
		)
	}(time.Now())
          next.ServeHTTP(lwr, r)
      })
  }
}


{{range . -}}{{$opid := .OperationId}}
func Make{{$opid}}Handler(svc Service) http.Handler {
return httptransport.NewServer(
		make{{$opid}}Endpoint(svc),
		{{ if .QueryParams }}
		Decode{{$opid}}Request,
		{{ else }}
		decode{{$opid}}Request,
		{{ end }}
		encodeResponse,
		httptransport.ServerErrorEncoder(encodeErrorResponse),
	)
}

func decode{{$opid}}Request(ctx context.Context, r *http.Request) (interface{}, error) {

{{ if .HasBody }}

var body {{range $index, $body := .Bodies}}{{if eq $index 0}}{{$body.Schema.GoType}}{{end}}{{end}}
if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
apiErr := APIError{Code: http.StatusBadRequest, Message: "decoding request body"}
return nil, apiErr.Wrap(err)
}
return body, nil

{{ else if and .PathParams (not .QueryParams)}}
vars := mux.Vars(r)

{{range .PathParams -}}
{{.ParamName}}Str, ok := vars["{{.ParamName}}"]

  {{if .Required }}
if !ok {
   return nil, Error(http.StatusBadRequest, "missing required parameter '{{.ParamName}}'")
}
  {{end}}

var {{.ParamName}} *{{.Schema.GoType}}
  {{if eq .Schema.GoType "int" }}
  
    {{if not .Required}}
if ok {
    {{end}}

param, err := strconv.Atoi({{.ParamName}}Str)
if err != nil {
  return nil, Error(http.StatusBadRequest, "invalid parameter '{{.ParamName}}', int required")
}
{{.ParamName}} = &param
    {{if not .Required}}
}
    {{end}}

  {{else if eq .Schema.GoType "float64"}}
  
    {{if not .Required}}
if ok {
    {{end}}
param, err := strconv.ParseFloat({{.ParamName}}Str, 64)
if err != nil {
  return nil, Error(http.StatusBadRequest, "invalid parameter '{{.ParamName}}', double required")
}
    {{if not .Required}}
}
    {{end}}


  {{else if eq .Schema.GoType "string"}}
  
    {{if not .Required}}
if ok {
    {{end}}
{{.ParamName}} = &{{.ParamName}}Str
    {{if not .Required}}
}
    {{end}}

  {{ else }}
  
    {{if not .Required}}
if ok {
    {{end}}
	{{.ParamName}}{{.Schema.GoType}} := {{.Schema.GoType}}({{.ParamName}}Str)
    {{.ParamName}} = &{{.ParamName}}{{.Schema.GoType}}
    {{if not .Required}}
}
    {{end}}
	
  {{end}}
  
{{end}}

return {{$opid}}Request {
{{range .PathParams -}}
{{.GoName}}: {{if .Required}}*{{end}}{{.ParamName}},
{{end}}
}, nil

{{ else if .QueryParams }}
  return nil, Error(http.StatusNotImplemented, "Decode{{$opid}}Request must be implemented by developer")
{{ else }}
  return nil, nil
{{ end }}
}

{{ if .QueryParams }}
// Decode{{$opid}}Request must be implemented by the developer (for now)
var Decode{{$opid}}Request = decode{{$opid}}Request
{{ end }}


{{ end }}

const headerXPoweredBy = "four elephants atop a giant turtle"

func encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
	w.Header().Set("x-powered-by", headerXPoweredBy)
	if response == nil {
	  return nil
	}
	w.Header().Set("content-type", "application/json")
	return json.NewEncoder(w).Encode(response)
}

func encodeErrorResponse(_ context.Context, err error, w http.ResponseWriter) {
	 code := http.StatusInternalServerError
	 if sc, ok := err.(httptransport.StatusCoder); ok {
	 	code = sc.StatusCode()
	 }
	
	 if _, ok := err.(json.Marshaler); !ok {
		err = Error(code, err.Error())
	 }

	 if headerer, ok := err.(httptransport.Headerer); ok {
		for k, values := range headerer.Headers() {
			for _, v := range values {
				w.Header().Add(k, v)
			}
		}
	}
	 
	 w.Header().Set("content-type", "application/json")
	 w.Header().Set("x-powered-by", headerXPoweredBy)
	 w.WriteHeader(code)
	 json.NewEncoder(w).Encode(err)
}


func toFixed(num float64, precision int) float64 {
	output := math.Pow(10, float64(precision))
	return float64(round(num*output)) / output
}

func round(num float64) int {
	return int(num + math.Copysign(0.5, num))
}
