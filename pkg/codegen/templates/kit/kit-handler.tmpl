type RouterOptions struct {
Prefix string
NotFoundHandler http.Handler
}

// GetRouter returns a github.com/gorilla/mux router with the routes
// in the spec already set up
func GetRouter(svc Service, logger kitlog.Logger, opts *RouterOptions) *mux.Router {
	 r := mux.NewRouter()
	 if logger != nil {
	 	logger = kitlog.With(logger, "layer", "httptransport")
	 	 r.Use(makeHTTPLoggingMiddleware(logger))
	 }
	prefix := ""
	var notFoundHandler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	 begin := time.Now()
	   encodeErrorResponse(r.Context(), Error(http.StatusNotFound, "not found"), w)
	duration := time.Since(begin)
	ms := toFixed(float64(time.Since(begin))/float64(time.Millisecond), 2)
	 if logger != nil {
		logger.Log(
			"method", r.Method,
			"path", r.URL.Path,
			"status", http.StatusNotFound,
			"duration", duration,
			"ms", ms,
		)
	 }
	 })
	if opts != nil {
		if opts.Prefix != "" {
			prefix = opts.Prefix
		}
		if prefix[0] != '/' {
			prefix = "/" + prefix
		}
		if prefix[len(prefix)-1] == '/' {
			prefix = prefix[0:len(prefix)-1]
		}

		if opts.NotFoundHandler != nil {
		   notFoundHandler = opts.NotFoundHandler
		}
	}
	
{{range . -}}{{$opid := .OperationId}}
	 r.Handle(fmt.Sprintf("%s{{.Path}}", prefix), Make{{$opid}}Handler(svc)).Methods("{{.Method}}")
{{end}}
	
	 r.NotFoundHandler = notFoundHandler
	 return r
}

	type loggingResponseWriter struct {
        http.ResponseWriter
        statusCode int
    }

    func newLoggingResponseWriter(w http.ResponseWriter) *loggingResponseWriter {
        return &loggingResponseWriter{w, http.StatusOK}
    }

    func (lrw *loggingResponseWriter) WriteHeader(code int) {
        lrw.statusCode = code
        lrw.ResponseWriter.WriteHeader(code)
    }

func makeHTTPLoggingMiddleware(logger kitlog.Logger) func(http.Handler) http.Handler {
  return func(next http.Handler) http.Handler {
      return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	  lwr := newLoggingResponseWriter(w)
	defer func(begin time.Time) {
	duration := time.Since(begin)
	ms := toFixed(float64(time.Since(begin))/float64(time.Millisecond), 2)
	if r.URL.Path == "/healthz" && lwr.statusCode == http.StatusOK { return; }
		logger.Log(
			"method", r.Method,
			"path", r.URL.Path,
			"status", lwr.statusCode,
			"duration", duration,
			"ms", ms,
		)
	}(time.Now())
          next.ServeHTTP(lwr, r)
      })
  }
}


type DecodeRequestFunc httptransport.DecodeRequestFunc

{{range . -}}{{$opid := .OperationId}}
// Make{{$opid}}Handler makes an http.Handler for the service method {{$opid}}.
//
// This is called automatically by GetRouter, but these are exported
// so that methods can be mounted manually with gorilla mux in the
// implementation
func Make{{$opid}}Handler(svc Service) http.Handler {
return httptransport.NewServer(
		make{{$opid}}Endpoint(svc),
		httptransport.DecodeRequestFunc(decode{{$opid}}Request),
		encodeResponse,
		httptransport.ServerErrorEncoder(encodeErrorResponse),
	)
}

var decode{{$opid}}Request DecodeRequestFunc = func(ctx context.Context, r *http.Request) (interface{}, error) {

{{ if .HasBody }}
contentType := r.Header.Get("content-type")
switch contentType {

{{ range .Bodies }}
case "{{.ContentType}}"{{ if .Default }}, ""{{end}}:
var body {{.Schema.GoType}}

{{ if eq .ContentType "application/json" }}
if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
apiErr := APIError{Code: http.StatusBadRequest, Message: "decoding request body"}
return nil, apiErr.Wrap(err)
}
return body, nil
{{ else }}
return nil, Error(http.StatusNotImplemented, "{{.ContentType}} bodies are not implemented by the generator")
{{ end }}

{{ end }}

default:
return nil, Errorf(http.StatusBadRequest, "'content-type: %s' not supported", contentType)
}

{{ else if .HasBody }}

body, err := io.ReadAll(r.Body)
if err != nil {
apiErr := APIError{Code: http.StatusInternalServerError, Message: "reading request body"}
return nil, apiErr.Wrap(err)
}
return string(body), nil

{{ else if and .PathParams (not .QueryParams)}}
vars := mux.Vars(r)

{{range .PathParams -}}
{{.ParamName}}Str, ok := vars["{{.ParamName}}"]

  {{if .Required }}
if !ok {
   return nil, Error(http.StatusBadRequest, "missing required parameter '{{.ParamName}}'")
}
  {{end}}

var {{.ParamName}} *{{.Schema.GoType}}
  {{if eq .Schema.GoType "int" }}
  
    {{if not .Required}}
if ok {
    {{end}}

param, err := strconv.Atoi({{.ParamName}}Str)
if err != nil {
  return nil, Error(http.StatusBadRequest, "invalid parameter '{{.ParamName}}', int required")
}
{{.ParamName}} = &param
    {{if not .Required}}
}
    {{end}}

  {{else if eq .Schema.GoType "int64"}}
  
    {{if not .Required}}
if ok {
    {{end}}
param, err := strconv.ParseInt({{.ParamName}}Str, 10, 64)
if err != nil {
  return nil, Error(http.StatusBadRequest, "invalid parameter '{{.ParamName}}', int required")
}
{{.ParamName}} = &param
    {{if not .Required}}
}
    {{end}}


  {{else if eq .Schema.GoType "float64"}}
  
    {{if not .Required}}
if ok {
    {{end}}
param, err := strconv.ParseFloat({{.ParamName}}Str, 64)
if err != nil {
  return nil, Error(http.StatusBadRequest, "invalid parameter '{{.ParamName}}', double required")
}
{{.ParamName}} = &param
    {{if not .Required}}
}
    {{end}}


  {{else if eq .Schema.GoType "string"}}
  
    {{if not .Required}}
if ok {
    {{end}}
{{.ParamName}} = &{{.ParamName}}Str
    {{if not .Required}}
}
    {{end}}

  {{ else }}
  
    {{if not .Required}}
if ok {
    {{end}}
	{{.ParamName}}{{.Schema.GoType}} := {{.Schema.GoType}}({{.ParamName}}Str)
    {{.ParamName}} = &{{.ParamName}}{{.Schema.GoType}}
    {{if not .Required}}
}
    {{end}}
	
  {{end}}
  
{{end}}

return {{$opid}}Request {
{{range .PathParams -}}
{{.GoName}}: {{if .Required}}*{{end}}{{.ParamName}},
{{end}}
}, nil

{{ else if .QueryParams }}
  return nil, Error(http.StatusNotImplemented, "Decode{{$opid}}Request must be implemented by developer and set by using SetDecode{{$opid}}Request")
{{ else }}
  return nil, nil
{{ end }}
}

// SetDecode{{$opid}}Request sets the request decoder for {{$opid}}
func SetDecode{{$opid}}Request(fn DecodeRequestFunc) {
decode{{$opid}}Request = fn
}


{{ end }}

const headerXPoweredBy = "four elephants atop a giant turtle"

func encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
	w.Header().Set("x-powered-by", headerXPoweredBy)
	if response == nil {
	  return nil
	}
	w.Header().Set("content-type", "application/json")
	return json.NewEncoder(w).Encode(response)
}

func encodeErrorResponse(_ context.Context, err error, w http.ResponseWriter) {
	 code := http.StatusInternalServerError
	 if sc, ok := err.(httptransport.StatusCoder); ok {
	 	code = sc.StatusCode()
	 }
	
	 if _, ok := err.(json.Marshaler); !ok {
		err = Error(code, err.Error())
	 }

	 if headerer, ok := err.(httptransport.Headerer); ok {
		for k, values := range headerer.Headers() {
			for _, v := range values {
				w.Header().Add(k, v)
			}
		}
	}
	 
	 w.Header().Set("content-type", "application/json")
	 w.Header().Set("x-powered-by", headerXPoweredBy)
	 w.WriteHeader(code)
	 json.NewEncoder(w).Encode(err)
}


func toFixed(num float64, precision int) float64 {
	output := math.Pow(10, float64(precision))
	return float64(round(num*output)) / output
}

func round(num float64) int {
	return int(num + math.Copysign(0.5, num))
}
