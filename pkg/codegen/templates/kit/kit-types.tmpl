// APIError implements the StatusCode, MarshalJSON, Unwrap, and Error
// methods and is intended to be used as a return from service methods
// when a non 500 return code is needed
type APIError struct {
     Code int `json:"code,omitempty"`
     Message string `json:"message,omitempty"`
     err error
}

// Error returns a new APIError with the code and message indicated
func Error(code int, message string) error {
     return APIError{Code: code, Message: message}
}

// Errorf returns a new APIError with the code and message derived
// from the format string and arguments
func Errorf(code int, format string, args ...interface{}) error {
     return APIError{Code: code, Message: fmt.Sprintf(format, args...)}
}

func (err APIError) Error() string {
     if err.err != nil {
        return fmt.Sprintf("[%d] %s: %s", err.Code, err.Message, err.err)
     }
     return fmt.Sprintf("[%d] %s", err.Code, err.Message)
}

func (err APIError) StatusCode() int {
     return err.Code
}

func (err APIError) MarshalJSON() ([]byte, error) {
     var message string
     if err.err != nil {
        message = fmt.Sprintf("%s: %s", err.Message, err.err)
     } else {
       message = err.Message
     }
     return []byte(fmt.Sprintf(`{"error": "%s"}`, message)), nil
}

func (err APIError) Wrap(towrap error) error {
     err.err = towrap
     return err
}

func (err APIError) Unwrap() error {
     return err.err
}

{{range .Types}}
{{ with .Schema.Description }}{{ . }}{{ else }}// {{.TypeName}} defines model for {{.JsonName}}.{{ end }}
type {{.TypeName}} {{if and (opts.AliasTypes) (.CanAlias)}}={{end}} {{.Schema.TypeDecl}}
{{end}}

func QueryGetSubValue[T comparable](values url.Values, prefix, key string, defaultVal T) T {
	keys := []string{
		key,
		fmt.Sprintf("%s[%s]", prefix, key),
		fmt.Sprintf("%s.%s", prefix, key),
	}

	var val T
	for _, key := range keys {
		val = QueryGetValue(values, key, defaultVal)
		if val != defaultVal {
			break
		}
	}
	return val
}

func QueryGetValue[T any](values url.Values, key string, defaultVal T) T {
	urlVal, ok := values[key]
	if !ok {
		return defaultVal
	}


	var ret any
	switch any(defaultVal).(type) {
	case string:
		ret = urlVal[0]
	case *string:
		ret = &(urlVal[0])
	case []string:
		ret = urlVal
	case []int:
		ints := make([]int, len(urlVal))
		for i, v := range urlVal {
			val, err := strconv.Atoi(v)
			if err != nil {
				continue
			}
			ints[i] = val
		}
		ret = ints
	case bool, *bool:
	    val, err := strconv.ParseBool(urlVal[0])
		if err != nil {
			return ret.(T)
		}
		switch any(defaultVal).(type) {
		  case int:
		  	   ret = val
		  case *int:
		  	   ret = &val
		}
	case int, *int:
	    val, err := strconv.Atoi(urlVal[0])
		if err != nil {
			return ret.(T)
		}
		switch any(defaultVal).(type) {
		  case int:
		  	   ret = val
		  case *int:
		  	   ret = &val
		}
	case float64, *float64:
	    val, err := strconv.ParseFloat(urlVal[0], 64)
		if err != nil {
			return ret.(T)
		}
		switch any(defaultVal).(type) {
		  case float64:
		  	   ret = val
		  case *float64:
		  	   ret = &val
		}
{{range .Types}}
{{- if (or
	(eq "int" .Schema.GoType)
	(eq "int32" .Schema.GoType)
	(eq "int64" .Schema.GoType)
	(eq "float64" .Schema.GoType)
	(eq "float32" .Schema.GoType)
	(eq "string" .Schema.GoType)
	(eq "bool" .Schema.GoType)) }}
	case {{.TypeName}}, *{{.TypeName}}:
{{- if (or
	(eq "int" .Schema.GoType)
	(eq "int32" .Schema.GoType)
	(eq "int64" .Schema.GoType)) }}
	    val, err := strconv.ParseInt(urlVal[0], 10, 64)
		if err != nil {
			return ret.(T)
		}
{{- else if (or
	(eq "float64" .Schema.GoType)
	(eq "float32" .Schema.GoType)) }}
	    val, err := strconv.ParseFloat(urlVal[0], 64)
		if err != nil {
			return ret.(T)
		}
{{- else if (eq "bool" .Schema.GoType) }}
	    val, err := strconv.ParseBool(urlVal[0])
		if err != nil {
			return ret.(T)
		}
{{- else }}
		val := urlVal[0]
{{- end}}
	    retVal := {{.TypeName}}(val)
		switch any(defaultVal).(type) {
		  case {{.TypeName}}:
		  	   ret = retVal
		  case *{{.TypeName}}:
		  	   ret = &retVal
		}
{{- end }}
{{end}}

    }
	return ret.(T)

}

