// APIError implements the StatusCode, MarshalJSON, Unwrap, and Error
// methods and is intended to be used as a return from service methods
// when a non 500 return code is needed
type APIError struct {
     Code int `json:"code,omitempty"`
     Message string `json:"message,omitempty"`
     err error
}

// Error returns a new APIError with the code and message indicated
func Error(code int, message string) error {
     return APIError{Code: code, Message: message}
}

// Errorf returns a new APIError with the code and message derived
// from the format string and arguments
func Errorf(code int, format string, args ...interface{}) error {
     return APIError{Code: code, Message: fmt.Sprintf(format, args...)}
}

// Errorw returns a new APIError with the code and message and
// wrapping the supplied error
func Errorw(code int, message string, err error) error {
     return (APIError{Code: code, Message: message}).Wrap(err)
}

func (err APIError) Error() string {
     if err.err != nil {
        return fmt.Sprintf("[%d] %s: %s", err.Code, err.Message, err.err)
     }
     return fmt.Sprintf("[%d] %s", err.Code, err.Message)
}

func (err APIError) StatusCode() int {
     return err.Code
}

func (err APIError) MarshalJSON() ([]byte, error) {
     var message string
     if err.err != nil {
        message = fmt.Sprintf("%s: %s", err.Message, err.err)
     } else {
       message = err.Message
     }
     return []byte(fmt.Sprintf(`{"error": "%s"}`, message)), nil
}

func (err APIError) Wrap(towrap error) error {
     err.err = towrap
     return err
}

func (err APIError) Unwrap() error {
     return err.err
}

{{range .Types}}
{{ with .Schema.Description }}{{ . }}{{ else }}// {{.TypeName}} defines model for {{.JsonName}}.{{ end }}
type {{.TypeName}} {{if and (opts.AliasTypes) (.CanAlias)}}={{end}} {{.Schema.TypeDecl}}
{{end}}

// QueryGetSubValue will get a value from a nested "parameter object".
//
// This will search the url values based on a few different key
// schema. For example:
//
// val := QueryGetSubValue[*string](r.URL.Query(), "filter", "search", nil)
//
// will search the query parameters for search, filter.search, and
// filter[search].
//
// Further nesting is possible by adding a . to the key
// parameter. For example:
//
// val := QueryGetSubValue[*string](r.URL.Query(), "filter", "updated_at.since", nil)
//
// will search the query parameters for updated_at.since,
// filter.updated_at.sinse, and filter[updated_at][since].
//
func QueryGetSubValue[T comparable](values url.Values, prefix, key string, defaultVal T) T {
	parts := strings.Split(key, ".")
	keys := []string{
		key,
		fmt.Sprintf("%s[%s]", prefix, strings.Join(parts, "][")),
		fmt.Sprintf("%s.%s", prefix, key),
	}

	var val T
	for _, key := range keys {
		val = QueryGetValue(values, key, defaultVal)
		if val != defaultVal {
			break
		}
	}
	return val
}

// QueryGetValue will try to get a value from the provided url.Values,
// returning the default value if not found
//
// To get a nil value, you must provide a type in the call, otherwise,
// go will infer the type. For example:
//
// val := QueryGetValue(r.URL.Query(), "foo", "bar")
// nilVal := QueryGetValue[*string](r.URL.Query(), "optional", nil)
//
func QueryGetValue[T any](values url.Values, key string, defaultVal T) T {
	urlVal, ok := values[key]
	if !ok {
		return defaultVal
	}


	var ret any
	switch any(defaultVal).(type) {
	case string:
		ret = urlVal[0]
	case *string:
		ret = &(urlVal[0])
	case []string:
		ret = urlVal
	case []int:
		ints := make([]int, len(urlVal))
		for i, v := range urlVal {
			val, err := strconv.Atoi(v)
			if err != nil {
				continue
			}
			ints[i] = val
		}
		ret = ints
	case bool, *bool:
        var val bool
        var err error
        if urlVal[0] == "" {
          val = true
        } else {
	      val, err = strconv.ParseBool(urlVal[0])
		  if err != nil {
	    		return defaultVal
		  }
        }
		switch any(defaultVal).(type) {
		  case bool:
		  	   ret = val
		  case *bool:
		  	   ret = &val
 		}
	case int, *int, uint, *uint:
	    val, err := strconv.Atoi(urlVal[0])
		if err != nil {
			return defaultVal
		}
		switch any(defaultVal).(type) {
		  case int:
		  	   ret = val
		  case *int:
		  	   ret = &val
		  case uint:
		  	   ret = uint(val)
		  case *uint:
               uval := uint(val)
		  	   ret = &uval
		}
	case int64, *int64:
	    val, err := strconv.ParseInt(urlVal[0], 10, 64)
		if err != nil {
			return defaultVal
		}
		switch any(defaultVal).(type) {
		  case int64:
		  	   ret = val
		  case *int64:
		  	   ret = &val
		}
	case float64, *float64:
	    val, err := strconv.ParseFloat(urlVal[0], 64)
		if err != nil {
			return defaultVal
		}
		switch any(defaultVal).(type) {
		  case float64:
		  	   ret = val
		  case *float64:
		  	   ret = &val
		}
{{range .Types}}
{{- if (or
	(eq "int" .Schema.GoType)
	(eq "int32" .Schema.GoType)
	(eq "int64" .Schema.GoType)
	(eq "float64" .Schema.GoType)
	(eq "float32" .Schema.GoType)
	(eq "string" .Schema.GoType)
	(eq "bool" .Schema.GoType)) }}
	case {{.TypeName}}, *{{.TypeName}}:
{{- if (or
	(eq "int" .Schema.GoType)
	(eq "int32" .Schema.GoType)
	(eq "int64" .Schema.GoType)) }}
	    val, err := strconv.ParseInt(urlVal[0], 10, 64)
		if err != nil {
			return defaultVal
		}
{{- else if (or
	(eq "float64" .Schema.GoType)
	(eq "float32" .Schema.GoType)) }}
	    val, err := strconv.ParseFloat(urlVal[0], 64)
		if err != nil {
			return defaultVal
		}
{{- else if (eq "bool" .Schema.GoType) }}
        var val bool
        var err error
        if urlVal[0] == "" {
          val = true
        } else {
	      val, err = strconv.ParseBool(urlVal[0])
		  if err != nil {
	    		return defaultVal
		  }
        }
{{- else }}
		val := urlVal[0]
{{- end}}
	    retVal := {{.TypeName}}(val)
		switch any(defaultVal).(type) {
		  case {{.TypeName}}:
		  	   ret = retVal
		  case *{{.TypeName}}:
		  	   ret = &retVal
		}
{{- end }}
{{end}}

    }
	return ret.(T)

}

