{{- if gt (len .SecuritySchemeProviderNames) 0 }}
const (
{{range $ProviderName := .SecuritySchemeProviderNames}}
    {{- $ProviderName | ucFirst}}Scopes = "{{$ProviderName}}.Scopes"
{{end}}
)
{{end}}

{{if gt (len .EnumDefinitions) 0 }}
{{range $Enum := .EnumDefinitions}}
// Defines values for {{$Enum.TypeName}}.
const (
{{- range $index, $value := $Enum.Schema.EnumValues}}
  {{$index}} {{$Enum.TypeName}} = {{$Enum.ValueWrapper}}{{$value}}{{$Enum.ValueWrapper}}
{{- end}}
)

// {{$Enum.TypeName}}List is a slice of all valid {{$Enum.TypeName}} enum types
var {{$Enum.TypeName}}List = []{{$Enum.TypeName}}{
{{- range $index, $value := $Enum.Schema.EnumValues}}
  {{$index}},
{{- end}}
}

// IsValid{{$Enum.TypeName}} checks if the supplied {{$Enum.TypeName}} is a
// valid enum value
{{- if eq $Enum.Schema.GoType "string" }}
func IsValid{{$Enum.TypeName}}[T {{$Enum.TypeName}} | {{$Enum.Schema.GoType}}] (thing T) bool {
for _, c := range {{$Enum.TypeName}}List {
if strings.EqualFold(string(thing), string(c)) {
return true
}
}
return false
}
{{- else }}
func IsValid{{$Enum.TypeName}}[T {{$Enum.TypeName}} | {{$Enum.Schema.GoType}}] (thing T) bool {
for _, c := range {{$Enum.TypeName}}List {
if {{$Enum.Schema.GoType}}(thing) == {{$Enum.Schema.GoType}}(c) {
return true
}
}
return false
}
{{end}}

{{end}}

// EnumMatchInsensitive checks if a two string type constants match
// ignoring case
func EnumMatchInsensitive[T string
{{- range $Enum := .EnumDefinitions -}}
{{- if eq $Enum.Schema.GoType "string" }} | {{$Enum.TypeName }}{{ end -}}
{{- end -}}
](thing1, thing2 T) bool {
	return strings.EqualFold(string(thing1), string(thing2))
}

var enumRegexp = regexp.MustCompile(`[^A-Z]+`)

// EnumNormalize normalizes string enum values
func EnumNormalize[T string
{{- range $Enum := .EnumDefinitions -}}
{{- if eq $Enum.Schema.GoType "string" }} | {{$Enum.TypeName }}{{ end -}}
{{- end -}}
](thing1 T) string {
	return enumRegexp.ReplaceAllString(strings.ToUpper(string(thing1)), "_")
}

{{end}}
